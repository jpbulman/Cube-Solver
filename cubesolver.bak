;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-reader.ss" "lang")((modname cubesolver) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
(define-struct cube (e1 e2 e3 e4 e5 e6 e7 e8 e9 e10 e11 e12 c1 c2 c3 c4 c5 c6 c7 c8 c9 solution))
(define-struct edge (sticker1 sticker2))
(define-struct corner (sticker1 sticker2 sticker3))

;Assuming a blue front yellow top for the cube

;Color code
; 1-White
; 2-Yellow
; 3-Blue
; 4-Green
; 5-Red
; 6-Orange

;Corners on the top layer have sticker1 starting on the top, then going ccw, sticker2 front, and sticker3
;Corners on the bottom layer have sticker1 on the bottom, going cw, sticker2 front, and then sticker3 right

;Top layer edges have sticker1 on top and sticker2 on front
;Front equator egdes have sticker1 front and sticker2 left | right
;Back equator edges have sticker1 on the back and sticker2 left | right
;Bottom edges have sticker1 on the bottom and sticker2 front

;Piece is a corner or an edge



;Edge=?
;Edge Edge -> Boolean
;Determines if the edges are equal
;Tests:
(check-expect (edge=? (make-edge 1 3) (make-edge 1 3)) true)
(check-expect (edge=? (make-edge 1 4) (make-edge 1 3)) false)

(define (edge=? e1 e2)
  (if (and (= (edge-sticker1 e1) (edge-sticker1 e2)) (= (edge-sticker2 e1) (edge-sticker2 e2)))
      true
      false))

;Oriented?
;Signature: Piece -> Boolean
;Checks if the piece is oriented properly
;Tests:
(check-expect (oriented? (make-corner 6 2 4)) false)
(check-expect (oriented? (make-corner 2 5 6)) true)
(check-expect (oriented? (make-edge 2 4)) true)
(check-expect (oriented? (make-edge 5 3)) false)
 
(define (oriented? p1)
  (if (edge? p1)
      (if (< (edge-sticker1 p1) 5)
      true
      false)
      (if (< (corner-sticker1 p1) 3)
      true
      false)))



;Solves a piece
;(define (solvepiece p1)
 ; (if (oriented? p1)
      ;(permute p1)
      ;(permute (orient p1))))





